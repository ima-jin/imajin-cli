---
# Metadata
title: "18.6.2 Type Safety Hardening - Part 2: Unsafe Member Access"
created: "2025-11-06T08:00:00Z"
updated: "2025-11-06T08:00:00Z"
---

# üõ°Ô∏è IMPLEMENT: Type Safety Hardening - Part 2: Unsafe Member Access

**Status:** üîÑ **READY TO START** (after 18.6.1)
**Phase:** 2 - Infrastructure Components (Type Safety - Part 2 of 3)
**Estimated Time:** 50-70 hours (1.5-2 weeks)
**Dependencies:** 18.6.1 Any Elimination (<200 any remaining)
**Prerequisites:** Core types defined, build passing

---

## üìã **CONTEXT**

We have **2,083 instances of unsafe member access** where TypeScript can't verify that properties exist on objects. This happens when accessing properties on `any`-typed values or dynamic objects.

**Current State:**
- ‚úÖ <200 explicit `any` usage (after 18.6.1)
- ‚ö†Ô∏è **2,083 `@typescript-eslint/no-unsafe-member-access` warnings**
- ‚ö†Ô∏è Each unsafe access is a potential `Cannot read property 'x' of undefined` runtime error

**Why This Matters:**
```typescript
// ‚ùå Unsafe - TypeScript can't help
const data: any = await fetchData();
const name = data.user.profile.name; // Runtime error if structure is different

// ‚úÖ Type-safe - Compile-time verification
interface ApiResponse {
  user: {
    profile: {
      name: string;
    };
  };
}
const data: ApiResponse = await fetchData();
const name = data.user.profile.name; // TypeScript verifies this exists
```

---

## üéØ **OBJECTIVES**

**Phase 2 Target:** Reduce unsafe member access from **2,083 ‚Üí <400** (81% reduction)

Focus on:
1. **Dynamic metadata access** (most common pattern)
2. **API response handling** (Stripe, Contentful, Cloudinary)
3. **Event data access** (event.data.someProperty)
4. **Container resolution results** (container.resolve('x').method())
5. **Recipe/entity property access** (recipe.entities[key].fields)

**Strategy:**
- Use type guards and assertions
- Define proper interfaces for dynamic data
- Use optional chaining where appropriate
- Add runtime validation for external data

---

## üìä **CURRENT BREAKDOWN**

### Common Patterns Causing Unsafe Access:

1. **Container resolution** (~200 instances)
```typescript
const service = container.resolve('someService');
service.someMethod(); // Unsafe - service is 'unknown'
```

2. **Metadata objects** (~500 instances)
```typescript
entity.metadata.customField; // Unsafe - metadata is any/unknown
```

3. **API responses** (~400 instances)
```typescript
const customer = await stripe.customers.create({...});
customer.metadata.userId; // Unsafe - Stripe types are loose
```

4. **Event data** (~300 instances)
```typescript
eventEmitter.on('event', (data) => {
  console.log(data.payload.value); // Unsafe - data is any
});
```

5. **Recipe/Entity fields** (~683 remaining)
```typescript
recipe.entities[entityName].fields.forEach(...); // Unsafe - entities is Record<string, any>
```

---

## üîß **TASK BREAKDOWN**

### **Task 1: Fix Container Resolution Access** (8-10 hours)

**Current:** ~200 unsafe member access from container.resolve()

#### 1.1 Type All Container Resolve Calls

After 18.6.1, container.resolve() should be typed:
```typescript
const service = container.resolve<ServiceType>('serviceName');
```

But if accessing properties immediately:
```typescript
// ‚ùå Still might be unsafe
container.resolve<any>('service').property

// ‚úÖ Proper typing
const service = container.resolve<ServiceType>('service');
service.property; // Now safe
```

#### 1.2 Find All Inline Member Access

```bash
# Find patterns like: container.resolve(...).something
grep -rn "container\.resolve.*\)\." src/
```

#### 1.3 Refactor Pattern

```typescript
// ‚ùå BEFORE - Inline access
const value = this.container.resolve('config').database.host;

// ‚úÖ AFTER - Separate and type
const config = this.container.resolve<AppConfig>('config');
const host = config.database.host;
```

**Success Criteria:**
- All container.resolve() followed by property access is typed
- No inline member access on resolve()
- ~200 errors resolved

---

### **Task 2: Fix Metadata Access** (12-16 hours)

**Current:** ~500 unsafe metadata access patterns

#### 2.1 Define Metadata Types

```typescript
// src/types/Metadata.ts

/**
 * Base metadata interface - allows extensibility
 */
export interface BaseMetadata {
  [key: string]: string | number | boolean | null | undefined;
}

/**
 * Stripe customer metadata
 */
export interface StripeCustomerMetadata extends BaseMetadata {
  userId?: string;
  accountType?: 'free' | 'premium' | 'enterprise';
  signupDate?: string;
  referralCode?: string;
}

/**
 * Contentful entry metadata
 */
export interface ContentfulMetadata extends BaseMetadata {
  workflow?: string;
  publishedBy?: string;
  tags?: string;
}

/**
 * Generic typed metadata access
 */
export function getMetadata<T extends BaseMetadata>(
  obj: { metadata?: unknown },
  key: keyof T
): T[keyof T] | undefined {
  if (!obj.metadata || typeof obj.metadata !== 'object') {
    return undefined;
  }
  return (obj.metadata as T)[key];
}
```

#### 2.2 Update Service Interfaces

```typescript
// src/services/stripe/types.ts

export interface StripeCustomer {
  id: string;
  email: string;
  name?: string;
  metadata: StripeCustomerMetadata; // ‚Üê Typed, not any
}
```

#### 2.3 Replace Unsafe Access

```typescript
// ‚ùå BEFORE
const userId = customer.metadata.userId; // Unsafe

// ‚úÖ AFTER - Option 1: Type assertion
const metadata = customer.metadata as StripeCustomerMetadata;
const userId = metadata.userId;

// ‚úÖ AFTER - Option 2: Helper function
const userId = getMetadata<StripeCustomerMetadata>(customer, 'userId');

// ‚úÖ AFTER - Option 3: Optional chaining with type
const userId = (customer.metadata as StripeCustomerMetadata)?.userId;
```

#### 2.4 Create Type Guards

```typescript
// src/types/guards.ts

export function hasMetadata<T extends BaseMetadata>(
  obj: unknown
): obj is { metadata: T } {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'metadata' in obj &&
    typeof (obj as any).metadata === 'object'
  );
}

export function isStripeMetadata(
  metadata: unknown
): metadata is StripeCustomerMetadata {
  if (typeof metadata !== 'object' || metadata === null) {
    return false;
  }
  // Validate structure
  return true; // Add proper validation
}
```

**Success Criteria:**
- All metadata objects properly typed
- Type guards available for runtime validation
- ~500 errors resolved

---

### **Task 3: Fix API Response Access** (10-14 hours)

**Current:** ~400 unsafe access on API responses

#### 3.1 Augment Third-Party Types

Create type augmentation files:

```typescript
// src/types/stripe.d.ts

import 'stripe';

declare module 'stripe' {
  namespace Stripe {
    interface Customer {
      metadata: StripeCustomerMetadata;
    }

    interface Subscription {
      metadata: StripeSubscriptionMetadata;
    }

    interface PaymentIntent {
      metadata: StripePaymentMetadata;
    }
  }
}
```

```typescript
// src/types/contentful.d.ts

import { Entry, Asset } from 'contentful';

declare module 'contentful' {
  interface Entry<T = any> {
    fields: T;
    metadata: ContentfulMetadata;
  }

  interface Asset {
    fields: AssetFields;
    metadata: ContentfulMetadata;
  }
}
```

#### 3.2 Define Response Interfaces

```typescript
// src/services/stripe/responses.ts

export interface CustomerResponse {
  success: boolean;
  message: string;
  customer: {
    id: string;
    email: string;
    name?: string;
    metadata: StripeCustomerMetadata;
    created: Date;
  };
  businessEntity?: BusinessEntityModel;
}
```

#### 3.3 Transform API Data to Typed

```typescript
// src/services/stripe/StripeService.ts

async createCustomer(params: CreateCustomerParams): Promise<CustomerResponse> {
  const stripeCustomer = await this.stripe.customers.create({
    email: params.email,
    name: params.name,
    metadata: params.metadata,
  });

  // Transform to properly typed response
  const customer: CustomerResponse['customer'] = {
    id: stripeCustomer.id,
    email: stripeCustomer.email,
    name: stripeCustomer.name ?? undefined,
    metadata: stripeCustomer.metadata as StripeCustomerMetadata,
    created: new Date(stripeCustomer.created * 1000),
  };

  return {
    success: true,
    message: 'Customer created successfully',
    customer,
  };
}
```

**Success Criteria:**
- Third-party types augmented where needed
- All API responses transformed to typed interfaces
- ~400 errors resolved

---

### **Task 4: Fix Event Data Access** (8-12 hours)

**Current:** ~300 unsafe event data access

#### 4.1 Type Event Emitter

Already defined in 18.6.1, now implement:

```typescript
// src/core/events/EventEmitter.ts

export class TypedEventEmitter implements IEventEmitter {
  on<TData = unknown>(
    eventName: string,
    handler: EventHandler<TData>
  ): void {
    // Implementation with type preservation
  }

  emit<TData = unknown>(eventName: string, data: TData): void {
    const event: IEvent<TData> = {
      id: randomUUID(),
      name: eventName,
      data,
      timestamp: new Date(),
    };
    // Emit with type information
  }
}
```

#### 4.2 Define Event Data Types

```typescript
// src/core/events/event-types.ts

export interface ServiceInitializedEventData {
  service: string;
  version: string;
  status: 'active' | 'degraded';
}

export interface EntityCreatedEventData {
  entityType: string;
  entityId: string;
  timestamp: Date;
  data: Record<string, unknown>;
}

export interface WorkflowCompletedEventData {
  workflowId: string;
  duration: number;
  success: boolean;
  results: unknown[];
}
```

#### 4.3 Update Event Handlers

```typescript
// ‚ùå BEFORE
eventEmitter.on('service:initialized', (event: any) => {
  console.log(event.data.service); // Unsafe
});

// ‚úÖ AFTER
eventEmitter.on<ServiceInitializedEventData>(
  'service:initialized',
  (event) => {
    console.log(event.data.service); // Type-safe
  }
);
```

#### 4.4 Create Event Registry

```typescript
// src/core/events/registry.ts

export interface EventRegistry {
  'service:initialized': ServiceInitializedEventData;
  'service:error': ServiceErrorEventData;
  'entity:created': EntityCreatedEventData;
  'workflow:completed': WorkflowCompletedEventData;
  // ... all events
}

// Type-safe emit
export function emitTypedEvent<K extends keyof EventRegistry>(
  emitter: IEventEmitter,
  eventName: K,
  data: EventRegistry[K]
): void {
  emitter.emit(eventName, data);
}
```

**Success Criteria:**
- All events properly typed
- Event handlers type-safe
- ~300 errors resolved

---

### **Task 5: Fix Recipe/Entity Access** (12-16 hours)

**Current:** ~683 unsafe access on recipes and entities

#### 5.1 Type Entity Records

```typescript
// From 18.6.1 types:
export interface Recipe {
  entities: Record<string, EntityDefinition>; // ‚Üê Already typed
  // ...
}
```

But access still unsafe:
```typescript
// ‚ùå Still unsafe due to Record<string, T>
const entity = recipe.entities[entityName];
entity.fields.forEach(...); // entity might be undefined
```

#### 5.2 Add Safe Access Helpers

```typescript
// src/context/helpers.ts

export function getEntity(
  recipe: Recipe,
  entityName: string
): EntityDefinition | undefined {
  return recipe.entities[entityName];
}

export function requireEntity(
  recipe: Recipe,
  entityName: string
): EntityDefinition {
  const entity = recipe.entities[entityName];
  if (!entity) {
    throw new Error(`Entity "${entityName}" not found in recipe`);
  }
  return entity;
}

export function hasEntity(recipe: Recipe, entityName: string): boolean {
  return entityName in recipe.entities;
}
```

#### 5.3 Replace Unsafe Access

```typescript
// ‚ùå BEFORE
const fields = recipe.entities[entityName].fields;

// ‚úÖ AFTER - Option 1: Helper
const entity = requireEntity(recipe, entityName);
const fields = entity.fields;

// ‚úÖ AFTER - Option 2: Optional chaining
const fields = recipe.entities[entityName]?.fields ?? [];

// ‚úÖ AFTER - Option 3: Type guard
if (hasEntity(recipe, entityName)) {
  const fields = recipe.entities[entityName].fields; // Now safe
}
```

#### 5.4 Type Workflow Access

```typescript
// Similar pattern for workflows
export function getWorkflow(
  recipe: Recipe,
  workflowId: string
): WorkflowDefinition | undefined {
  return recipe.workflows?.find(w => w.id === workflowId);
}
```

**Success Criteria:**
- Safe helpers for entity access
- Optional chaining used appropriately
- ~683 errors resolved

---

### **Task 6: Remaining Patterns** (6-10 hours)

Fix remaining ~200 miscellaneous unsafe member access

#### 6.1 Dynamic Property Access

```typescript
// ‚ùå BEFORE
const value = obj[dynamicKey].property;

// ‚úÖ AFTER
const intermediate = obj[dynamicKey as keyof typeof obj];
if (intermediate && typeof intermediate === 'object') {
  const value = (intermediate as any).property; // Document why any needed
}
```

#### 6.2 Conditional Properties

```typescript
// ‚ùå BEFORE
if (response.error) {
  console.log(response.error.message);
}

// ‚úÖ AFTER - Type guard
interface ErrorResponse {
  error: { message: string };
}

function hasError(response: unknown): response is ErrorResponse {
  return (
    typeof response === 'object' &&
    response !== null &&
    'error' in response
  );
}

if (hasError(response)) {
  console.log(response.error.message); // Type-safe
}
```

#### 6.3 External Library Types

For libraries without types, create declarations:

```typescript
// src/types/third-party.d.ts

declare module 'untyped-library' {
  export interface LibraryOptions {
    key: string;
    value: number;
  }

  export function someFunction(opts: LibraryOptions): Promise<any>;
}
```

**Success Criteria:**
- All remaining patterns addressed
- Type guards used for runtime safety
- ~200 errors resolved

---

## ‚úÖ **SUCCESS CRITERIA**

### Critical Criteria (Must Pass):
- [ ] Unsafe member access: 2,083 ‚Üí <400 (81% reduction)
- [ ] All metadata properly typed
- [ ] API responses type-safe
- [ ] Event system type-safe
- [ ] Recipe/entity access safe
- [ ] TypeScript compilation passes
- [ ] Tests pass (74% maintained)
- [ ] Build succeeds

### Quality Criteria (Should Pass):
- [ ] Type guards available for dynamic data
- [ ] Optional chaining used appropriately
- [ ] No `as any` escapes without documentation
- [ ] Runtime validation for external data

---

## üß™ **TESTING STRATEGY**

### Type Safety Tests:
```typescript
// src/__type-tests__/metadata.test-d.ts
import { expectType } from 'tsd';

const customer: StripeCustomer = {
  id: 'cus_123',
  email: 'test@test.com',
  metadata: {
    userId: '123',
    accountType: 'premium',
  },
};

// Should be type-safe
expectType<string | undefined>(customer.metadata.userId);
expectType<'free' | 'premium' | 'enterprise' | undefined>(customer.metadata.accountType);

// Should error on non-existent property
// @ts-expect-error
customer.metadata.nonExistent;
```

### Runtime Safety Tests:
```typescript
// Test type guards work correctly
describe('Type Guards', () => {
  test('hasMetadata identifies objects with metadata', () => {
    const withMetadata = { metadata: { key: 'value' } };
    const withoutMetadata = { other: 'data' };

    expect(hasMetadata(withMetadata)).toBe(true);
    expect(hasMetadata(withoutMetadata)).toBe(false);
  });
});
```

---

## üìä **PROGRESS TRACKING**

| Task | Errors Before | Target | Actual | Time Est. | Actual |
|------|--------------|--------|--------|-----------|---------|
| Container resolution | ~200 | 0 | - | 8-10h | - |
| Metadata access | ~500 | 0 | - | 12-16h | - |
| API responses | ~400 | 0 | - | 10-14h | - |
| Event data | ~300 | 0 | - | 8-12h | - |
| Recipe/Entity access | ~683 | 0 | - | 12-16h | - |
| Remaining patterns | ~200 | <100 | - | 6-10h | - |
| **TOTAL** | **2,083** | **<400** | **-** | **56-78h** | **-** |

---

## üîó **INTEGRATION POINTS**

### Before This Prompt:
- 18.6.1 Any Elimination (<200 any)
- Core types defined

### After This Prompt:
- 18.6.3 Unsafe Assignments/Calls (1,948 instances)
- Near-complete type safety

---

## üìù **IMPLEMENTATION NOTES**

### Best Practices:
1. **Type guards over assertions**: `if (isType(x))` better than `x as Type`
2. **Optional chaining**: Use `?.` for potentially undefined properties
3. **Helper functions**: Create typed accessors for common patterns
4. **Document any escapes**: If `as any` is needed, explain why

### Code Review Checklist:
- [ ] Type guards added for runtime validation
- [ ] Optional chaining used appropriately
- [ ] No `as any` without documentation
- [ ] Tests updated with type assertions
- [ ] Third-party types augmented if needed

---

**Status:** Ready after 18.6.1
**Priority:** üî¥ Critical - Member access safety
**Next:** 18.6.3 Unsafe Assignments/Calls

---

*Part 2 of 3: Unsafe Member Access*
*Target: 81% reduction (2,083 ‚Üí <400)*
