/**
 * TypeGenerator - TypeScript type generation from schemas
 * 
 * @package     @imajin/cli
 * @subpackage  schemas
 * @author      Generated
 * @copyright   imajin
 * @license     .fair LICENSING AGREEMENT
 * @version     0.1.0
 * @since       2025-06-13
 * @updated      2025-07-03
 *
 * Integration Points:
 * - TypeScript interface generation from schemas
 * - Zod schema generation for runtime validation
 * - Service adapter template generation
 */

import { promises as fs } from 'node:fs';
import type { 
    SchemaDefinition, 
    EntityDefinition, 
    FieldDefinition 
} from './types/SchemaTypes.js';

// =============================================================================
// TYPE GENERATOR CLASS
// =============================================================================

export class TypeGenerator {
    private readonly generatedHeader = `/**
 * Generated Types - Auto-generated from external schemas
 * 
 * @package     @imajin/cli
 * @subpackage  schemas/generated
 * @author      Generated by TypeGenerator
 * @copyright   imajin
 * @license     .fair LICENSING AGREEMENT
 * @version     0.1.0
 * @since       ${new Date().toISOString().split('T')[0]}
 *
 * ⚠️ WARNING: This file is auto-generated. Do not edit manually!
 * Changes will be overwritten when schemas are updated.
 */`;

    /**
     * Generate TypeScript interfaces from schema
     */
    generateInterface(schema: SchemaDefinition): string {
        const interfaces: string[] = [];
        
        // Generate interfaces for each entity
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const interfaceCode = this.generateSingleInterface(entityName, entityDef, schema);
            interfaces.push(interfaceCode);
        }

        return interfaces.join('\n\n');
    }

    /**
     * Generate Zod schemas from external definitions
     */
    generateZodSchema(schema: SchemaDefinition): string {
        const imports = "import { z } from 'zod';";
        const zodSchemas: string[] = [];
        
        // Generate Zod schemas for each entity
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const zodCode = this.generateSingleZodSchema(entityName, entityDef, schema);
            zodSchemas.push(zodCode);
        }

        return `${imports}\n\n${zodSchemas.join('\n\n')}`;
    }

    /**
     * Generate complete types file
     */
    generateTypesFile(schemas: Map<string, SchemaDefinition>): string {
        const sections: string[] = [this.generatedHeader];
        
        // Add imports
        sections.push("import { z } from 'zod';");
        
        // Generate types for each schema
        for (const [schemaName, schema] of schemas.entries()) {
            sections.push(this.generateSchemaSection(schemaName, schema));
        }

        // Add exports
        sections.push(this.generateExports(schemas));

        return sections.join('\n\n');
    }

    /**
     * Generate service adapter template
     */
    generateAdapterTemplate(schema: SchemaDefinition, serviceName: string): string {
        const adapters: string[] = [];
        
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const adapterCode = this.generateSingleAdapter(entityName, entityDef, serviceName);
            adapters.push(adapterCode);
        }

        return `${this.generatedHeader}\n\nimport { ServiceAdapter, ServiceNamespace } from '../types/Core.js';\n\n${adapters.join('\n\n')}`;
    }

    /**
     * Write generated types to file
     */
    async writeTypesFile(schemas: Map<string, SchemaDefinition>, outputPath: string): Promise<void> {
        const content = this.generateTypesFile(schemas);
        await fs.writeFile(outputPath, content, 'utf8');
    }

    // =============================================================================
    // PRIVATE GENERATION METHODS
    // =============================================================================

    /**
     * Generate single TypeScript interface
     */
    private generateSingleInterface(entityName: string, entityDef: EntityDefinition, _schema: SchemaDefinition): string {
        const lines: string[] = [];

        // Add JSDoc comment
        const description = entityDef.description || `${entityName} entity`;
        lines.push(
            `/**`,
            ` * ${description}`,
            ` */`
        );
        
        // Interface declaration
        const extendsClause = entityDef.extends ? ` extends ${entityDef.extends}` : '';
        lines.push(`export interface ${entityName}${extendsClause} {`);
        
        // Generate fields
        for (const [fieldName, fieldDef] of Object.entries(entityDef.fields)) {
            const fieldLine = this.generateInterfaceField(fieldName, fieldDef);
            lines.push(`    ${fieldLine}`);
        }
        
        lines.push('}');
        
        return lines.join('\n');
    }

    /**
     * Generate single Zod schema
     */
    private generateSingleZodSchema(entityName: string, entityDef: EntityDefinition, _schema: SchemaDefinition): string {
        const lines: string[] = [];
        
        // Schema declaration
        lines.push(`export const ${entityName}Schema = z.object({`);
        
        // Generate fields
        for (const [fieldName, fieldDef] of Object.entries(entityDef.fields)) {
            const fieldLine = this.generateZodField(fieldName, fieldDef);
            lines.push(`    ${fieldLine}`);
        }
        
        lines.push(
            '});',
            '',
            `export type ${entityName} = z.infer<typeof ${entityName}Schema>;`
        );
        
        return lines.join('\n');
    }

    /**
     * Generate interface field
     */
    private generateInterfaceField(fieldName: string, fieldDef: FieldDefinition): string {
        const optional = fieldDef.required ? '' : '?';
        const type = this.mapToTypeScriptType(fieldDef);
        const comment = fieldDef.description ? ` // ${fieldDef.description}` : '';
        
        return `${fieldName}${optional}: ${type};${comment}`;
    }

    /**
     * Generate Zod field
     */
    private generateZodField(fieldName: string, fieldDef: FieldDefinition): string {
        let zodType = this.mapToZodType(fieldDef);
        
        // Add optional/required
        if (!fieldDef.required) {
            zodType += '.optional()';
        }
        
        // Add comment
        const comment = fieldDef.description ? ` // ${fieldDef.description}` : '';
        
        return `${fieldName}: ${zodType},${comment}`;
    }

    /**
     * Map field definition to TypeScript type
     */
    private mapToTypeScriptType(fieldDef: FieldDefinition): string {
        switch (fieldDef.type) {
            case 'string':
            case 'email':
                return 'string';
            case 'number':
                return 'number';
            case 'boolean':
                return 'boolean';
            case 'date':
            case 'datetime':
                return 'Date';
            case 'enum':
                if (fieldDef.values) {
                    return fieldDef.values.map(v => `'${v}'`).join(' | ');
                }
                return 'string';
            case 'array':
                if (fieldDef.items) {
                    const itemType = this.mapToTypeScriptType(fieldDef.items);
                    return `${itemType}[]`;
                }
                return 'any[]';
            case 'object':
                return 'Record<string, any>';
            default:
                return 'any';
        }
    }

    /**
     * Map field definition to Zod type
     */
    private mapToZodType(fieldDef: FieldDefinition): string {
        switch (fieldDef.type) {
            case 'string':
                return 'z.string()';
            case 'email':
                return 'z.string().email()';
            case 'number':
                return 'z.number()';
            case 'boolean':
                return 'z.boolean()';
            case 'date':
            case 'datetime':
                return 'z.date()';
            case 'enum':
                if (fieldDef.values && fieldDef.values.length > 0) {
                    const values = fieldDef.values.map(v => `'${v}'`).join(', ');
                    return `z.enum([${values}])`;
                }
                return 'z.string()';
            case 'array':
                return 'z.array(z.any())';
            case 'object':
                return 'z.record(z.any())';
            default:
                return 'z.any()';
        }
    }

    /**
     * Generate schema section
     */
    private generateSchemaSection(schemaName: string, schema: SchemaDefinition): string {
        const lines: string[] = [];

        lines.push(
            `// =============================================================================`,
            `// ${schemaName.toUpperCase()} SCHEMA (${schema.namespace})`,
            `// ${schema.description}`,
            `// =============================================================================`
        );
        
        // Generate interfaces
        const interfaces = this.generateInterface(schema);
        lines.push(interfaces);
        
        lines.push('');
        
        // Generate Zod schemas
        const zodSchemas = this.generateZodSchema(schema);
        lines.push('', zodSchemas);
        
        return lines.join('\n');
    }

    /**
     * Generate exports section
     */
    private generateExports(schemas: Map<string, SchemaDefinition>): string {
        const lines: string[] = [];

        lines.push(
            '// =============================================================================',
            '// EXPORTS',
            '// ============================================================================='
        );
        
        const exportLines: string[] = [];

        for (const [_schemaName, schema] of schemas.entries()) {
            exportLines.push(
                ...Object.keys(schema.entities).flatMap(entityName => [
                    `export type { ${entityName} };`,
                    `export { ${entityName}Schema };`
                ])
            );
        }

        lines.push(...exportLines);
        
        return lines.join('\n');
    }

    /**
     * Generate service adapter template
     */
    private generateSingleAdapter(entityName: string, entityDef: EntityDefinition, serviceName: string): string {
        const lines: string[] = [];

        lines.push(
            `/**`,
            ` * ${serviceName} ${entityName} Adapter`,
            ` */`,
            `export class ${serviceName}${entityName}Adapter implements ServiceAdapter<${serviceName}${entityName}, Universal${entityName}> {`
        );
        
        // toUniversal method
        lines.push(
            `    toUniversal(serviceEntity: ${serviceName}${entityName}): Universal${entityName} {`,
            `        return {`,
            `            // Map common universal fields`,
            `            id: serviceEntity.id,`,
            `            createdAt: new Date(serviceEntity.created || Date.now()),`,
            `            updatedAt: new Date(),`,
            `            metadata: {},`,
            `            serviceData: { ${serviceName.toLowerCase()}: serviceEntity },`,
            `            sourceService: '${serviceName.toLowerCase()}',`,
            `            // Map entity-specific fields from ${serviceName} format`,
            `            ...this.mapEntitySpecificFields(serviceEntity),`,
            `        } as Universal${entityName};`,
            `    }`,
            '',
            // fromUniversal method
            `    fromUniversal(universalEntity: Universal${entityName}): ${serviceName}${entityName} {`,
            `        // Extract ${serviceName}-specific data if available`,
            `        const serviceData = universalEntity.serviceData.${serviceName.toLowerCase()} || {};`,
            `        return {`,
            `            // Use original service data when available`,
            `            ...serviceData,`,
            `            // Ensure universal fields are mapped back`,
            `            id: universalEntity.id,`,
            `            // Map entity-specific fields to ${serviceName} format`,
            `            ...this.mapFromUniversalFields(universalEntity),`,
            `        } as ${serviceName}${entityName};`,
            `    }`,
            '',
            // validate method
            `    validate(entity: unknown): entity is ${serviceName}${entityName} {`,
            `        // Implement comprehensive validation`,
            `        try {`,
            `            if (!entity || typeof entity !== 'object') return false;`,
            `            const obj = entity as Record<string, any>;`,
            `            // Validate required ID field`,
            `            if (!obj.id || typeof obj.id !== 'string') return false;`,
            `            // Add additional ${serviceName}-specific validation here`,
            `            return true;`,
            `        } catch {`,
            `            return false;`,
            `        }`,
            `    }`,
            '',
            // getNamespace method
            `    getNamespace(): ServiceNamespace {`,
            `        return '${serviceName.toLowerCase()}';`,
            `    }`,
            '}'
        );
        
        return lines.join('\n');
    }
} 