/**
 * TypeGenerator - TypeScript type generation from schemas
 * 
 * @package     @imajin/cli
 * @subpackage  schemas
 * @author      Generated
 * @copyright   imajin
 * @license     .fair LICENSING AGREEMENT
 * @version     0.1.0
 * @since       2025-06-13
 *
 * Integration Points:
 * - TypeScript interface generation from schemas
 * - Zod schema generation for runtime validation
 * - Service adapter template generation
 */

import { promises as fs } from 'fs';
import * as path from 'path';
import type { 
    SchemaDefinition, 
    EntityDefinition, 
    FieldDefinition 
} from './types/SchemaTypes.js';

// =============================================================================
// TYPE GENERATOR CLASS
// =============================================================================

export class TypeGenerator {
    private readonly generatedHeader = `/**
 * Generated Types - Auto-generated from external schemas
 * 
 * @package     @imajin/cli
 * @subpackage  schemas/generated
 * @author      Generated by TypeGenerator
 * @copyright   imajin
 * @license     .fair LICENSING AGREEMENT
 * @version     0.1.0
 * @since       ${new Date().toISOString().split('T')[0]}
 *
 * ⚠️ WARNING: This file is auto-generated. Do not edit manually!
 * Changes will be overwritten when schemas are updated.
 */`;

    /**
     * Generate TypeScript interfaces from schema
     */
    generateInterface(schema: SchemaDefinition): string {
        const interfaces: string[] = [];
        
        // Generate interfaces for each entity
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const interfaceCode = this.generateSingleInterface(entityName, entityDef, schema);
            interfaces.push(interfaceCode);
        }

        return interfaces.join('\n\n');
    }

    /**
     * Generate Zod schemas from external definitions
     */
    generateZodSchema(schema: SchemaDefinition): string {
        const imports = "import { z } from 'zod';";
        const zodSchemas: string[] = [];
        
        // Generate Zod schemas for each entity
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const zodCode = this.generateSingleZodSchema(entityName, entityDef, schema);
            zodSchemas.push(zodCode);
        }

        return `${imports}\n\n${zodSchemas.join('\n\n')}`;
    }

    /**
     * Generate complete types file
     */
    generateTypesFile(schemas: Map<string, SchemaDefinition>): string {
        const sections: string[] = [this.generatedHeader];
        
        // Add imports
        sections.push("import { z } from 'zod';");
        
        // Generate types for each schema
        for (const [schemaName, schema] of schemas.entries()) {
            sections.push(this.generateSchemaSection(schemaName, schema));
        }

        // Add exports
        sections.push(this.generateExports(schemas));

        return sections.join('\n\n');
    }

    /**
     * Generate service adapter template
     */
    generateAdapterTemplate(schema: SchemaDefinition, serviceName: string): string {
        const adapters: string[] = [];
        
        for (const [entityName, entityDef] of Object.entries(schema.entities)) {
            const adapterCode = this.generateSingleAdapter(entityName, entityDef, serviceName);
            adapters.push(adapterCode);
        }

        return `${this.generatedHeader}\n\nimport { ServiceAdapter, ServiceNamespace } from '../types/Core.js';\n\n${adapters.join('\n\n')}`;
    }

    /**
     * Write generated types to file
     */
    async writeTypesFile(schemas: Map<string, SchemaDefinition>, outputPath: string): Promise<void> {
        const content = this.generateTypesFile(schemas);
        await fs.writeFile(outputPath, content, 'utf8');
    }

    // =============================================================================
    // PRIVATE GENERATION METHODS
    // =============================================================================

    /**
     * Generate single TypeScript interface
     */
    private generateSingleInterface(entityName: string, entityDef: EntityDefinition, schema: SchemaDefinition): string {
        const lines: string[] = [];
        
        // Add JSDoc comment
        lines.push(`/**`);
        lines.push(` * ${entityDef.description || `${entityName} entity`}`);
        lines.push(` */`);
        
        // Interface declaration
        const extendsClause = entityDef.extends ? ` extends ${entityDef.extends}` : '';
        lines.push(`export interface ${entityName}${extendsClause} {`);
        
        // Generate fields
        for (const [fieldName, fieldDef] of Object.entries(entityDef.fields)) {
            const fieldLine = this.generateInterfaceField(fieldName, fieldDef);
            lines.push(`    ${fieldLine}`);
        }
        
        lines.push('}');
        
        return lines.join('\n');
    }

    /**
     * Generate single Zod schema
     */
    private generateSingleZodSchema(entityName: string, entityDef: EntityDefinition, schema: SchemaDefinition): string {
        const lines: string[] = [];
        
        // Schema declaration
        lines.push(`export const ${entityName}Schema = z.object({`);
        
        // Generate fields
        for (const [fieldName, fieldDef] of Object.entries(entityDef.fields)) {
            const fieldLine = this.generateZodField(fieldName, fieldDef);
            lines.push(`    ${fieldLine}`);
        }
        
        lines.push('});');
        
        // Type inference
        lines.push('');
        lines.push(`export type ${entityName} = z.infer<typeof ${entityName}Schema>;`);
        
        return lines.join('\n');
    }

    /**
     * Generate interface field
     */
    private generateInterfaceField(fieldName: string, fieldDef: FieldDefinition): string {
        const optional = fieldDef.required ? '' : '?';
        const type = this.mapToTypeScriptType(fieldDef);
        const comment = fieldDef.description ? ` // ${fieldDef.description}` : '';
        
        return `${fieldName}${optional}: ${type};${comment}`;
    }

    /**
     * Generate Zod field
     */
    private generateZodField(fieldName: string, fieldDef: FieldDefinition): string {
        let zodType = this.mapToZodType(fieldDef);
        
        // Add optional/required
        if (!fieldDef.required) {
            zodType += '.optional()';
        }
        
        // Add comment
        const comment = fieldDef.description ? ` // ${fieldDef.description}` : '';
        
        return `${fieldName}: ${zodType},${comment}`;
    }

    /**
     * Map field definition to TypeScript type
     */
    private mapToTypeScriptType(fieldDef: FieldDefinition): string {
        switch (fieldDef.type) {
            case 'string':
            case 'email':
                return 'string';
            case 'number':
                return 'number';
            case 'boolean':
                return 'boolean';
            case 'date':
            case 'datetime':
                return 'Date';
            case 'enum':
                if (fieldDef.values) {
                    return fieldDef.values.map(v => `'${v}'`).join(' | ');
                }
                return 'string';
            case 'array':
                if (fieldDef.items) {
                    const itemType = this.mapToTypeScriptType(fieldDef.items);
                    return `${itemType}[]`;
                }
                return 'any[]';
            case 'object':
                return 'Record<string, any>';
            default:
                return 'any';
        }
    }

    /**
     * Map field definition to Zod type
     */
    private mapToZodType(fieldDef: FieldDefinition): string {
        switch (fieldDef.type) {
            case 'string':
                return 'z.string()';
            case 'email':
                return 'z.string().email()';
            case 'number':
                return 'z.number()';
            case 'boolean':
                return 'z.boolean()';
            case 'date':
            case 'datetime':
                return 'z.date()';
            case 'enum':
                if (fieldDef.values && fieldDef.values.length > 0) {
                    const values = fieldDef.values.map(v => `'${v}'`).join(', ');
                    return `z.enum([${values}])`;
                }
                return 'z.string()';
            case 'array':
                return 'z.array(z.any())';
            case 'object':
                return 'z.record(z.any())';
            default:
                return 'z.any()';
        }
    }

    /**
     * Generate schema section
     */
    private generateSchemaSection(schemaName: string, schema: SchemaDefinition): string {
        const lines: string[] = [];
        
        lines.push(`// =============================================================================`);
        lines.push(`// ${schemaName.toUpperCase()} SCHEMA (${schema.namespace})`);
        lines.push(`// ${schema.description}`);
        lines.push(`// =============================================================================`);
        
        // Generate interfaces
        const interfaces = this.generateInterface(schema);
        lines.push(interfaces);
        
        lines.push('');
        
        // Generate Zod schemas
        const zodSchemas = this.generateZodSchema(schema);
        lines.push(zodSchemas);
        
        return lines.join('\n');
    }

    /**
     * Generate exports section
     */
    private generateExports(schemas: Map<string, SchemaDefinition>): string {
        const lines: string[] = [];
        
        lines.push('// =============================================================================');
        lines.push('// EXPORTS');
        lines.push('// =============================================================================');
        
        const exportLines: string[] = [];
        
        for (const [schemaName, schema] of schemas.entries()) {
            for (const entityName of Object.keys(schema.entities)) {
                exportLines.push(`export type { ${entityName} };`);
                exportLines.push(`export { ${entityName}Schema };`);
            }
        }
        
        lines.push(...exportLines);
        
        return lines.join('\n');
    }

    /**
     * Generate service adapter template
     */
    private generateSingleAdapter(entityName: string, entityDef: EntityDefinition, serviceName: string): string {
        const lines: string[] = [];
        
        lines.push(`/**`);
        lines.push(` * ${serviceName} ${entityName} Adapter`);
        lines.push(` */`);
        lines.push(`export class ${serviceName}${entityName}Adapter implements ServiceAdapter<${serviceName}${entityName}, Universal${entityName}> {`);
        
        // toUniversal method
        lines.push(`    toUniversal(serviceEntity: ${serviceName}${entityName}): Universal${entityName} {`);
        lines.push(`        return {`);
        lines.push(`            // Map common universal fields`);
        lines.push(`            id: serviceEntity.id,`);
        lines.push(`            createdAt: new Date(serviceEntity.created || Date.now()),`);
        lines.push(`            updatedAt: new Date(),`);
        lines.push(`            metadata: {},`);
        lines.push(`            serviceData: { ${serviceName.toLowerCase()}: serviceEntity },`);
        lines.push(`            sourceService: '${serviceName.toLowerCase()}',`);
        lines.push(`            // Map entity-specific fields from ${serviceName} format`);
        lines.push(`            ...this.mapEntitySpecificFields(serviceEntity),`);
        lines.push(`        } as Universal${entityName};`);
        lines.push(`    }`);
        
        lines.push('');
        
        // fromUniversal method
        lines.push(`    fromUniversal(universalEntity: Universal${entityName}): ${serviceName}${entityName} {`);
        lines.push(`        // Extract ${serviceName}-specific data if available`);
        lines.push(`        const serviceData = universalEntity.serviceData.${serviceName.toLowerCase()} || {};`);
        lines.push(`        return {`);
        lines.push(`            // Use original service data when available`);
        lines.push(`            ...serviceData,`);
        lines.push(`            // Ensure universal fields are mapped back`);
        lines.push(`            id: universalEntity.id,`);
        lines.push(`            // Map entity-specific fields to ${serviceName} format`);
        lines.push(`            ...this.mapFromUniversalFields(universalEntity),`);
        lines.push(`        } as ${serviceName}${entityName};`);
        lines.push(`    }`);
        
        lines.push('');
        
        // validate method
        lines.push(`    validate(entity: unknown): entity is ${serviceName}${entityName} {`);
        lines.push(`        // Implement comprehensive validation`);
        lines.push(`        try {`);
        lines.push(`            if (!entity || typeof entity !== 'object') return false;`);
        lines.push(`            const obj = entity as Record<string, any>;`);
        lines.push(`            // Validate required ID field`);
        lines.push(`            if (!obj.id || typeof obj.id !== 'string') return false;`);
        lines.push(`            // Add additional ${serviceName}-specific validation here`);
        lines.push(`            return true;`);
        lines.push(`        } catch {`);
        lines.push(`            return false;`);
        lines.push(`        }`);
        lines.push(`    }`);
        
        lines.push('');
        
        // getNamespace method
        lines.push(`    getNamespace(): ServiceNamespace {`);
        lines.push(`        return '${serviceName.toLowerCase()}';`);
        lines.push(`    }`);
        
        lines.push('}');
        
        return lines.join('\n');
    }
} 